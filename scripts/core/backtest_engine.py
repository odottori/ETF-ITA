#!/usr/bin/env python3
"""
Backtest Engine - ETF Italia Project v10.7.2
Simulazione reale con esecuzione ordini e contabilizzazione fiscale
Risolve il problema "reporting senza simulazione"
"""

import sys
import os
import json
import duckdb
import pandas as pd
from datetime import datetime, timedelta

# Aggiungi root al path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from session_manager import get_session_manager

class BacktestEngine:
    """Motore di backtest con simulazione reale"""
    
    def __init__(self, db_path, config_path):
        self.db_path = db_path
        self.config_path = config_path
        self.conn = None
        self.config = None
        
    def connect(self):
        """Connette al database"""
        self.conn = duckdb.connect(self.db_path)
        
        # Carica configurazione
        with open(self.config_path, 'r') as f:
            self.config = json.load(f)
    
    def initialize_portfolio(self, initial_capital=20000.0):
        """Inizializza portfolio con capitale iniziale"""
        
        # Pulisci ledger precedente
        self.conn.execute("DELETE FROM fiscal_ledger WHERE run_type = 'BACKTEST'")
        
        # Deposito iniziale
        self.conn.execute("""
        INSERT INTO fiscal_ledger (
            date, type, symbol, qty, price, fees, tax_paid, 
            pmc_snapshot, run_type, notes
        ) VALUES (?, 'DEPOSIT', 'CASH', 1, ?, 0, 0, ?, 'BACKTEST', 'Initial capital')
        """, [
            datetime.now().date(),
            initial_capital,
            initial_capital
        ])
        
        print(f"‚úÖ Portfolio inizializzato con ‚Ç¨{initial_capital:,.2f}")
        
    def run_simulation(self, start_date, end_date):
        """Esegue simulazione completa dal periodo specificato"""
        
        print(f"üöÄ SIMULAZIONE BACKTEST: {start_date} ‚Üí {end_date}")
        print("=" * 60)
        
        # 1. Calcola segnali per il periodo
        print("üìä Calcolo segnali...")
        self.conn.execute("""
        DELETE FROM signals WHERE date BETWEEN ? AND ?
        """, [start_date, end_date])
        
        self.conn.execute("""
        INSERT INTO signals (date, symbol, signal_type, signal_strength, risk_scalar)
        SELECT 
            date,
            symbol,
            CASE 
                WHEN trend > 0.5 AND momentum > 0.5 THEN 'RISK_ON'
                WHEN trend < -0.5 OR momentum < -0.5 THEN 'RISK_OFF'
                ELSE 'HOLD'
            END as signal_type,
            (trend + momentum) / 2 as signal_strength,
            COALESCE(rm.risk_scalar, 1.0) as risk_scalar
        FROM market_data md
        LEFT JOIN risk_metrics rm ON md.symbol = rm.symbol AND md.date = rm.date
        WHERE md.date BETWEEN ? AND ?
        AND md.symbol IN (SELECT symbol FROM etf_universe WHERE active = true)
        """, [start_date, end_date])
        
        # 2. Genera ordini basati su segnali
        print("üìã Generazione ordini...")
        self.conn.execute("""
        DELETE FROM orders WHERE date BETWEEN ? AND ? AND status = 'PENDING'
        """, [start_date, end_date])
        
        self.conn.execute("""
        INSERT INTO orders (date, symbol, order_type, qty, price, status, notes)
        SELECT 
            s.date,
            s.symbol,
            CASE 
                WHEN s.signal_type = 'RISK_ON' THEN 'BUY'
                WHEN s.signal_type = 'RISK_OFF' THEN 'SELL'
                ELSE 'HOLD'
            END as order_type,
            CASE 
                WHEN s.signal_type = 'RISK_ON' THEN 
                    FLOOR(20000 * s.signal_strength * s.risk_scalar / md.close)
                WHEN s.signal_type = 'RISK_OFF' THEN 
                    COALESCE(fl.position_qty, 0)
                ELSE 0
            END as qty,
            md.close as price,
            'PENDING' as status,
            'Generated by backtest' as notes
        FROM signals s
        JOIN market_data md ON s.date = md.date AND s.symbol = md.symbol
        LEFT JOIN (
            SELECT symbol, SUM(CASE WHEN type = 'BUY' THEN qty ELSE -qty END) as position_qty
            FROM fiscal_ledger 
            WHERE type IN ('BUY', 'SELL')
            GROUP BY symbol
        ) fl ON s.symbol = fl.symbol
        WHERE s.date BETWEEN ? AND ?
        AND s.signal_type IN ('RISK_ON', 'RISK_OFF')
        AND CASE 
            WHEN s.signal_type = 'RISK_ON' THEN 
                FLOOR(20000 * s.signal_strength * s.risk_scalar / md.close) > 0
            WHEN s.signal_type = 'RISK_OFF' THEN 
                COALESCE(fl.position_qty, 0) > 0
            ELSE false
        END
        """, [start_date, end_date])
        
        # 3. Esegui ordini
        print("‚ö° Esecuzione ordini...")
        orders = self.conn.execute("""
        SELECT date, symbol, order_type, qty, price
        FROM orders 
        WHERE date BETWEEN ? AND ? 
        AND status = 'PENDING'
        ORDER BY date, symbol
        """, [start_date, end_date]).fetchall()
        
        for order_date, symbol, order_type, qty, price in orders:
            self._execute_order(order_date, symbol, order_type, qty, price)
        
        print(f"‚úÖ Eseguiti {len(orders)} ordini")
        
    def _execute_order(self, date, symbol, order_type, qty, price):
        """Esegue singolo ordine con logica fiscale"""
        
        commission = qty * price * 0.001  # 0.1% commission
        slippage = qty * price * 0.0005  # 0.05% slippage
        total_cost = qty * price + commission + slippage
        
        if order_type == 'BUY':
            # Acquisto
            self.conn.execute("""
            INSERT INTO fiscal_ledger (
                date, type, symbol, qty, price, fees, tax_paid, 
                pmc_snapshot, run_type, notes
            ) VALUES (?, 'BUY', ?, ?, ?, ?, 0, 
                (SELECT COALESCE(SUM(pmc_snapshot), 0) FROM fiscal_ledger WHERE date < ?), 
                'BACKTEST', 'Backtest execution')
            """, [date, symbol, qty, price, commission, date])
            
        elif order_type == 'SELL':
            # Vendita con calcolo fiscale
            avg_cost = self.conn.execute("""
            SELECT COALESCE(SUM(qty * price) / SUM(qty), 0) as avg_cost
            FROM fiscal_ledger 
            WHERE symbol = ? AND type = 'BUY' AND date <= ?
            """, [symbol, date]).fetchone()[0]
            
            proceeds = qty * price - commission - slippage
            cost_basis = qty * avg_cost
            gain = proceeds - cost_basis
            
            tax = gain * 0.26 if gain > 0 else 0
            
            self.conn.execute("""
            INSERT INTO fiscal_ledger (
                date, type, symbol, qty, price, fees, tax_paid, 
                pmc_snapshot, run_type, notes
            ) VALUES (?, 'SELL', ?, ?, ?, ?, ?, 
                (SELECT COALESCE(SUM(pmc_snapshot), 0) FROM fiscal_ledger WHERE date < ?), 
                'BACKTEST', 'Backtest execution')
            """, [date, symbol, qty, price, commission, tax, date])
    
    def calculate_portfolio_value(self, date):
        """Calcola valore portfolio alla data specifica"""
        
        # Posizioni aperte
        positions = self.conn.execute("""
        SELECT 
            fl.symbol,
            SUM(CASE WHEN fl.type = 'BUY' THEN fl.qty ELSE -fl.qty END) as net_qty,
            md.close as current_price
        FROM fiscal_ledger fl
        JOIN market_data md ON fl.symbol = md.symbol AND md.date = ?
        WHERE fl.date <= ?
        AND fl.type IN ('BUY', 'SELL')
        GROUP BY fl.symbol, md.close
        HAVING net_qty > 0
        """, [date, date]).fetchall()
        
        market_value = sum(qty * price for _, qty, price in positions)
        
        # Cash disponibile
        cash = self.conn.execute("""
        SELECT COALESCE(SUM(CASE 
            WHEN type = 'DEPOSIT' THEN qty * price - fees - tax_paid
            WHEN type = 'SELL' THEN qty * price - fees - tax_paid
            WHEN type = 'BUY' THEN -(qty * price + fees)
            ELSE 0 
        END), 0) as cash_balance
        FROM fiscal_ledger
        WHERE date <= ? AND run_type = 'BACKTEST'
        """, [date]).fetchone()[0]
        
        return market_value + cash
    
    def create_portfolio_overview(self, start_date, end_date):
        """Crea vista portfolio_overview basata su simulazione reale"""
        
        print("üìä Creazione portfolio_overview da simulazione...")
        
        # Elimina vista precedente
        self.conn.execute("DROP VIEW IF EXISTS portfolio_overview")
        
        # Crea tabella temporanea con valori portfolio giornalieri
        self.conn.execute("""
        CREATE TEMP TABLE daily_portfolio AS
        SELECT 
            date,
            symbol,
            adj_close,
            volume,
            market_value,
            qty,
            cash
        FROM (
            SELECT 
                md.date,
                md.symbol,
                md.adj_close,
                md.volume,
                COALESCE(fl.net_qty * md.close, 0) as market_value,
                COALESCE(fl.net_qty, 0) as qty,
                0 as cash
            FROM market_data md
            LEFT JOIN (
                SELECT 
                    symbol,
                    date,
                    SUM(CASE WHEN type = 'BUY' THEN qty ELSE -qty END) as net_qty
                FROM fiscal_ledger fl
                WHERE run_type = 'BACKTEST'
                AND type IN ('BUY', 'SELL')
                GROUP BY symbol, date
            ) fl ON md.symbol = fl.symbol AND md.date >= fl.date
            WHERE md.date BETWEEN ? AND ?
            AND md.symbol IN (SELECT DISTINCT symbol FROM fiscal_ledger WHERE run_type = 'BACKTEST')
        ) t
        ORDER BY date, symbol
        """, [start_date, end_date])
        
        # Crea vista portfolio_overview
        self.conn.execute("""
        CREATE OR REPLACE VIEW portfolio_overview AS
        SELECT * FROM daily_portfolio
        ORDER BY date, symbol
        """)
        
        print("‚úÖ portfolio_overview creato da dati reali")
    
    def calculate_real_kpi(self, start_date, end_date):
        """Calcola KPI basati su simulazione reale"""
        
        # Ottieni valori portfolio giornalieri
        portfolio_values = []
        current_date = start_date
        
        while current_date <= end_date:
            try:
                value = self.calculate_portfolio_value(current_date)
                portfolio_values.append((current_date, value))
            except:
                pass
            current_date += timedelta(days=1)
        
        if not portfolio_values:
            return self._empty_kpi()
        
        df = pd.DataFrame(portfolio_values, columns=['date', 'portfolio_value'])
        df['date'] = pd.to_datetime(df['date'])
        df.set_index('date', inplace=True)
        
        # Calcola returns
        df['daily_return'] = df['portfolio_value'].pct_change(fill_method=None)
        df = df.dropna()
        
        if len(df) == 0:
            return self._empty_kpi()
        
        # KPI reali
        initial_value = df['portfolio_value'].iloc[0]
        final_value = df['portfolio_value'].iloc[-1]
        
        days = (df.index[-1] - df.index[0]).days
        cagr = (final_value / initial_value) ** (365.25 / days) - 1 if days > 0 else 0.0
        
        # Max drawdown
        df['cummax'] = df['portfolio_value'].cummax()
        df['drawdown'] = (df['portfolio_value'] - df['cummax']) / df['cummax']
        max_dd = df['drawdown'].min()
        
        # Volatilit√† e Sharpe
        vol = df['daily_return'].std() * (252 ** 0.5)
        sharpe = cagr / vol if vol > 0 else 0.0
        
        # Turnover reale
        turnover = self._calculate_turnover(start_date, end_date)
        
        return {
            'cagr': cagr,
            'max_dd': max_dd,
            'vol': vol,
            'sharpe': sharpe,
            'turnover': turnover,
            'initial_value': initial_value,
            'final_value': final_value,
            'total_return': (final_value - initial_value) / initial_value
        }
    
    def _calculate_turnover(self, start_date, end_date):
        """Calcola turnover reale basato su ordini eseguiti"""
        
        total_traded = self.conn.execute("""
        SELECT COALESCE(SUM(qty * price), 0) as total_traded
        FROM fiscal_ledger
        WHERE date BETWEEN ? AND ?
        AND run_type = 'BACKTEST'
        AND type IN ('BUY', 'SELL')
        """, [start_date, end_date]).fetchone()[0]
        
        avg_portfolio_value = self.conn.execute("""
        SELECT AVG(portfolio_value) as avg_value
        FROM (
            SELECT date, SUM(qty * price) as portfolio_value
            FROM fiscal_ledger fl
            JOIN market_data md ON fl.symbol = md.symbol AND fl.date = md.date
            WHERE fl.date BETWEEN ? AND ?
            AND fl.run_type = 'BACKTEST'
            AND fl.type IN ('BUY', 'SELL')
            GROUP BY date
        ) t
        """, [start_date, end_date]).fetchone()[0] or 1
        
        return (total_traded / avg_portfolio_value) / 2 if avg_portfolio_value > 0 else 0.0
    
    def _empty_kpi(self):
        """Ritorna KPI vuoti"""
        return {
            'cagr': 0.0,
            'max_dd': 0.0,
            'vol': 0.0,
            'sharpe': 0.0,
            'turnover': 0.0,
            'initial_value': 0.0,
            'final_value': 0.0,
            'total_return': 0.0
        }
    
    def close(self):
        """Chiudi connessione"""
        if self.conn:
            self.conn.close()

def run_backtest_simulation():
    """Funzione principale per esecuzione backtest con simulazione"""
    
    print("üöÄ BACKTEST ENGINE - ETF Italia Project v10.7.2")
    print("=" * 60)
    
    # Path configurazione
    root_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    config_path = os.path.join(root_dir, 'config', 'etf_universe.json')
    db_path = os.path.join(root_dir, 'data', 'etf_data.duckdb')
    
    # Inizializza engine
    engine = BacktestEngine(db_path, config_path)
    
    try:
        engine.connect()
        
        # Periodo backtest (ultimo anno)
        end_date = datetime.now().date()
        start_date = end_date - timedelta(days=365)
        
        # 1. Inizializza portfolio
        engine.initialize_portfolio(20000.0)
        
        # 2. Esegui simulazione
        engine.run_simulation(start_date, end_date)
        
        # 3. Crea portfolio_overview reale
        engine.create_portfolio_overview(start_date, end_date)
        
        # 4. Calcola KPI reali
        kpi = engine.calculate_real_kpi(start_date, end_date)
        
        # 5. Report risultati
        print(f"\nüìä BACKTEST RESULTS (SIMULAZIONE REALE):")
        print(f"Periodo: {start_date} ‚Üí {end_date}")
        print(f"Valore Iniziale: ‚Ç¨{kpi['initial_value']:,.2f}")
        print(f"Valore Finale: ‚Ç¨{kpi['final_value']:,.2f}")
        print(f"Return Totale: {kpi['total_return']:.2%}")
        print(f"CAGR: {kpi['cagr']:.2%}")
        print(f"Max Drawdown: {kpi['max_dd']:.2%}")
        print(f"Sharpe Ratio: {kpi['sharpe']:.2f}")
        print(f"Volatility: {kpi['vol']:.2%}")
        print(f"Turnover: {kpi['turnover']:.2%}")
        
        print(f"\n‚úÖ Backtest con simulazione reale completato")
        return True
        
    except Exception as e:
        print(f"‚ùå Errore backtest engine: {e}")
        return False
        
    finally:
        engine.close()

if __name__ == "__main__":
    success = run_backtest_simulation()
    sys.exit(0 if success else 1)
